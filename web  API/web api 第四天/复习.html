<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <input type="button" value="点击" id="btn">
    <div id="dv">
        <ul id="uu">
            <li></li>
            <li></li>
            <li></li>
            <li></li>
        </ul>

    </div>

    <script src="common.js"></script>
    <script>
        /*   节点：页面中所有的内容都是节点（标签，属性，文本（文字，空格，换行））
                                文档：document 页面中顶级对象
                                元素：页面中所有的标签（标签可以叫元素，也可以叫对象）------
                                                      ------通过DOM的方式来获取这个标签，得到了这个对象，此时这个对象叫DOM对象      
                                节点的属性：作用，为了将来获取很多节点，得到节点中的标签，识别节点中的标签元素
                                           nodeType:节点类型  1--标签节点、2--属性节点、3--文本节点
                                           nodeName：标签节点----大写的标签的名字，属性节点----小写的属性名，文本节点-----#text
                                           nodeValue：标签----null，属性==属性的值，文本---文本内容
                                           if(node.nodeType==1&&node.nodeName=="P"&&node.nodeValue==null)//p节点
                                获取节点及元素的代码（12种）
                                           获取当前节点的父级
                                           获取当前节点父级元素
                                           获取当前节点的子级节点
                                           获取当前节点的子级元素
                                           获取当前节点的第一个子级节点
                                           获取当前节点的第一个子级元素
                                           获取当前节点的最后一个子级节点
                                           获取当前节点的
                                            获取当前节点的前一个兄弟节点
                                           获取当前节点
                                            获取当前节点的后一个节点
                                           获取当前
                                三种元素创建的方式：
                                1、document.write("标签代码及内容");//缺点：页面加载完毕后，页面中内容会被覆盖
                                2、对象.innerHTML="标签代码及内容"      //大量嵌套适合这种方式
                                3、document.createElement("标签名字")；//得到对象
                                    父级元素.appendChild("子级元素对象")//两种配合
                                    当然不止这一种追加方式
                                    父级元素.inerstBefore(新的子级对象，参照的子级对象)

                 

                                  事件的绑定：为同一个元素，绑定多个相同时间
                                     三种方式
                                        1、对象.on事件名字=事件处理函数   //多个后面的覆盖前面的
                                        2、对象.addEventListener("没有no的事件名字"，时间处理函数，false)
                                        3、对象》attachEvent（"有on的事件名字"，事件处理函数）
                                  
                                  */

        //  获取当前节点的父级
        console.log(my$("uu").parentNode);
        //  获取当前节点父级元素
        console.log(my$("uu").parentElement);
        //  获取当前节点的子级节点
        console.log(my$("uu").childNodes);
        //  获取当前节点的子级元素
        console.log(my$("uu").children);
        //  获取当前节点的第一个子级节点
        console.log(my$("uu").firstChild);
        //  获取当前节点的第一个子级元素
        console.log(my$("uu").firstElementChild);
        //  获取当前节点的最后一个子级节点
        console.log(my$("uu").lastChild);
        //  获取当前节点的最后一个子级元素
        console.log(my$("uu").lastElementChild);
        //  获取当前节点的前一个兄弟节点
        console.log(my$("uu").previousSibling);
        //  获取当前节点的前一个兄弟元素
        console.log(my$("uu").previousElementSibling);
        //  获取当前节点的后一个节点
        console.log(my$("uu").nextSibling);
        //  获取当前节点的后一个元素
        console.log(my$("uu").nextElementSibling);



        //写兼容代码
        function addEventListener(element, type, fn) {
            if (element.addEventListener) {
                //支持
                element.addEventListener(type, fn, false)
            } else {
                element.attachEvent(type, fn, false)
            } else {

            }
        }
    </script>
</body>

</html>